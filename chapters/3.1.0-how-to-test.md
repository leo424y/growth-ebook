如何編寫測試
---

寫測試相比於寫程式碼來說算是一件簡單的事。多數時候，我們並不需要考慮複雜的邏輯。我們只需要按照我們的程式碼邏輯，對程式碼的行為進行覆蓋。

需要注意的是——在不同的團隊、工作流裡，測試可能是會有不同的工作流程：

 - 開發人員寫單元測試、整合測試等等
 - 測試團隊通過介面來做黑盒測試
 - 測試人員手動測試來測試功能

在允許的情況下，測試應該由開發人員來編寫，並且是由底層開始寫測試。為了更好地去測試程式碼，我們需要了解測試金字塔。

###測試金字塔

測試金字塔是由 Mike Cohn 提出的，主要觀點是：底層單元測試應多於依賴 GUI 的高層端到端測試。其結構圖如下所示：

![測試金字塔](assets/article/chapter3/test-pyramid.png)

從結構上來說，上面的金字塔可以分成三部分：

1. 單元測試。
2. 服務測試
3. UI 測試

從圖中我們可以發現：單元測試應該要是最多的，也是最底層的。其次才是服務測試，最後才是 UI 測試。大量的單元測試可以保證我們的基礎函數是正常、正確工作的。而服務測試則是一門很有學問的測試，不僅僅只在測試我們自己提供的服務，也會測試我們依賴第三方提供的服務。在測試第三方提供的服務時，這就會變成一件有意思的事了。除此還有對功能和 UI 的測試，寫這些測試可以減輕測試人員的工作量——畢竟這些工作量轉向了開發人員來完成。

####單元測試

單元測試是針對程式模組（軟體設計的最小單位）來進行正確性檢驗的測試工作。它是應用的最小可測試部件。舉個例子來說，下面是一個JavaScript 的函數，用於判斷一個變數是否是一個物件：

```
var isObject = function (obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
};
```

這是一個很簡單的功能，對應的我們會有一個簡單的 Jasmine 測試來保證這個函數是正常工作的：

```javascript
it("should be a object", function () {
    expect(l.isObject([])).toEqual(true);
    expect(l.isObject([{}])).toEqual(true);
});
```

雖然這個測試看上去很簡單，但是大量的基本的單元測試可以保證我們呼叫的函數都是可以正常工作的。這也相當於是我們在建設金字塔時用的石塊——如果我們的石塊都是經常測試的，那麼我們就不怕金字塔因為石塊的損壞而坍塌。

當單元測試達到一定的覆蓋率，我們的程式碼就會變得更健壯。因為我們都需要保證我們的程式碼都是可測的，也意味著我們程式碼間的耦合度會降低。我們需要去考慮程式碼的長度，越長的程式碼在測試的時間會變得越困難。這也就是為什麼 TDD 會促使我們寫出短的程式碼。如果我們的程式碼都是有測試的，單元測試可以幫助我們在未來重構我們的程式碼。

並且在很多沒有文件或者文件不完整的開源項目中，瞭解這個項目某個函數的用法就是檢視他的測試用例。測試用例（Test Case）是為某個特殊目標而編制的一組測試輸入、執行條件以及預期結果，以便測試某個程式路徑或核實是否滿足某個特定需求。這些測試用例可以讓我們直觀地理解程式程式的 API。

####服務測試

服務測試顧名思義便是對服務進行測試，而服務可以是有不同的類型，不同層次的測試。如第三方的 API 服務、我們程式提供的服務，雖然他們他應該在這一個層級上進行測試，但是對他們的測試會稍有不同。

對於第三方的提供的 API 服務或者其他類似的服務，在這一個層級的測試，我們都不會真實地去測試他們能不能工作——這些依賴性的服務只會在功能測試上進行測試。在這裡的測試，我們只會保證我們的功能程式碼是可以正常工作的，所以我們會使用一些虛假的 API 測試資料來進行測試。這一類提供 API 的 Mock Server 可以模擬被測系統外部依賴模組行為的通用服務。我們只要保證我們的功能程式碼是正常工作的，那麼依賴他的服務也會是正常工作的。

![Mock Server](assets/article/chapter3/mock-server.png)

而對於我們提供的服務來說，這一類的服務不一定是 API 的服務，還有可能是多個函陣列成的功能性服務。當我們在測試這些服務的時候，實際上是在測試這個函數結合在一起是不是正常的。

一個服務可能依賴於多個函數，因而我們會發現服務測試的數量是少於單元測試的。

####UI 測試

在傳統的軟體開發中，UI 測試多數是由人手動來完成的。而在稍後的章節裡，你將會看到這些工作是可以由機器自己來完成的——當然，前提是我們要編寫這些自動化測試的程式碼。需要注意的是 UI 測試並不能完全替代手工的工作，一些測試還是應該由人來進行測試——如對 UI 的佈局，在現階段機器還沒有審美意識呢。

自動化 UI 測試是一個緩慢的過程，在這個過程裡我們需要做這麼幾件事：

1. 執行起我們的網站——這可能需要幾分鐘。
2. 新增一些 Mock 的資料，以使網站看上去正常——這也需要幾分鐘到幾十分鐘的時間。
3. 開始執行測試——在一些依賴於網路的測試中，執行完一個測試可能會需要幾分鐘。儘管可以並行執行測試，但是一個測試幾分鐘算到最後就會累積成很長的時間。

所以，你會發現這是一個很長的測試過程。儘可能地將這個層級的測試往下層級移，就會盡可能的節省時間。一個 UI 測試需要幾分鐘，但是一個單元測試可能不到1秒。這就意味著，這樣的測試下移可以節省上百個數量級的時間。

###如何測試

現在問題來了，我們應該怎麼去寫測試？換句話來說，我要測什麼？這是一個很難的問題，這足夠可以以一本書的幅度來說明這個問題。這個問題也需要依賴於不同的實踐，不同的時候我們可能對問題的看法都有不同。

編寫測試的過程大致可以分成下面的幾個步驟：

1. 瞭解測試目的(Why)？即我們需要測什麼，我們是為了什麼而編寫的測試。
2. 我們要測哪些內容(What)？即測試點，我們即要從功能點上出發來尋找需要我們測試的點，在不同的條件下這個測試點是不一樣的。
3. 我們要如何進行測試(How)？我們要使用怎麼樣的方法進行測試？

####測試目的

我們在上面提到過的測試金字塔，也表明了我們在每個層級要測試的目的是不一樣的。

在單元測試這一層級，因為我們所測試的是每一個函數，這些函數沒有辦法構成完整的功能。這時候我們就只是用於簡簡單單的測試函數本身的功能，沒有太多的業務需求。

而對於服務這一層級，我們所要測試的就是一個完整的功能。對於以 API 為主的項目來說，實際上就是在測返回結果是否是正確的。

最後 UI 這一層級，我們所需要測試的就是一個完整的功能。使用者操作的時候應該是怎樣的，那麼我們就應該模仿使用者的行為來測試。這是一個完整的業務需求，也可以稱之為驗證測試。

####測試點

在瞭解完我們要測試的目的之後，我們要測試的點也變得很清晰。即在單元測試測試我們的函數的功能，在我們的服務測試我們的服務，在我們的 UI測試測試業務。

而這些都理想的情況，當系統由於業務的原因不得不耦合的時候。究竟是單元測試還是功能測試，這是一個特別值得思考的問題。如果一個功能既可以在單元測試裡測，又可以在服務測試裡測，那麼我們要測試哪一個？或者說我們應該把兩個都測一遍？而如果是花費時間更長的 UI 測試呢？這樣做是不是會變得不划算。

####如何寫測試程式碼

先讓來們來簡單地看一下測試用例，然後再讓我們看看一般情況下我們是如何寫測試程式碼的。下面的程式碼是一個用Python寫的測試用例：

```python
class HomepageTestCase(LiveServerTestCase):
    def setUp(self):
        self.selenium = webdriver.Firefox()
        self.selenium.maximize_window()
        super(HomepageTestCase, self).setUp()

    def tearDown(self):
        self.selenium.quit()
        super(HomepageTestCase, self).tearDown()

    def test_can_visit_homepage(self):
        self.selenium.get(
            '%s%s' % (self.live_server_url,  "/")
        )

        self.assertIn("Welcome to my blog", self.selenium.title)
```

在上面的程式碼裡主要有三個方法，setUp()、tearDown()和 test_can_visit_homepage()。在這三個方法中起主要作用的是 test_can_visit_homepage()方法。而 setUp() 和 tearDown() 是特殊的方法，分別在測試方法開始之前執行和之後執行。同時，在這裡我們也用這兩個方法來開啟和關閉瀏覽器。

而在我們的測試方法 test_can_visit_homepage() 裡，主要有兩個步驟：

1. 訪問首頁
2. 驗證首頁的標題是“Welcome to my blog”

大部分的測試程式碼也是以如何的流程來執行著。有一點需要注意的是：一般來說函數名就表示了這個測試所要做測試的事情，如這裡就是測試可以訪問首頁。

如上所示的測試過程稱為“四階段測試”，即這個過程分為如下的四個階段：

1. **Setup**。在這個階段主要是做一些準備工作，如資料準備和初始化等等，在上面的 setup 階段就是用 selenium 啟動了一個 Firefox 瀏覽器，然後把視窗最大化了。
2. **Execute**。在執行階段就是做好驗證結果前的工作，如我們在測試註冊的時候，那麼這裡就是填寫資料，並點選提交按鈕。在上面的程式碼裡，我們只是開啟了首頁。
3. **Verify**。在驗證階段，我們所要做的就是驗證返回的結果是否和我們預期的一致。在這裡我們還是使用和單元測試一樣的 assert 來做斷言，通過判斷這個頁面的標題是"Welcome to my blog"，來說明我們現在就是在首頁裡。
4. **Tear Down**。就是一些收尾工作啦 ，比如關閉瀏覽器、清除測試資料等等。

####Tips

需要注意的幾點是：

1. 從執行測試速度上來看，三種測試的執行速度是呈倒金字塔結構。即，單元測試跑得最快，開發速度也越快。隨後是服務測試，最後是 UI 測試。
2. 即使現在的 UI 測試跑得非常快，但是隨著時間的推移，UI 測試會越來越多。這也意味著測試來跑得越來越久，那麼人們就開始不想測試了。在我們之前的項目裡，執行完所有的測試大概接近一個小時，我們開始在會議會爭論這些測試的必要性，也在想方設法減少這些測試。
3. 如果一個測試可以在最底層寫，那麼就不要在他的上一層寫了，因為他的執行速度更快。

參考書籍:

 - 《優質程式碼——軟體測試的原則、實踐與模式》
 - 《Python Web 開發： 測試驅動開發方法》
