資料持久化
---

資訊源於資料，我們在網站上看到的內容都應該是屬於資訊的範疇。這些資訊是應用從資料庫中根據業務需求查詢、過濾出來的資料。

資料通常以檔案的形式儲存，畢竟檔案是儲存資訊的基本單位。只是由於業務本身對於 Create、Update、Query、Index 等有不同的組合需求就引發了不同的資料儲存軟體。

如上章所說，View 層直接從 Model 層取資料，無疑也會暴露資料的模型。作為一個前端開發人員，我們對資料的操作有三種類型：

1. 資料庫。由於 Node.js 在最近幾年裡發展迅猛，越來越多的開發者選擇使用 Node.js 作為後臺語言。這與傳統的 Model 層並無多大不同，要麼直接操作資料庫，要麼間接操作資料庫。即使在 NoSQL 資料庫中也是如此。
2. 搜尋引擎。對於以查詢為主的領域來說，搜尋引擎是一個更好的選擇，而搜尋引擎又不好直接向 View 層暴露介面。這和招聘資訊一樣，都在暴露公司的技術棧。
3. RESTful。RESTful 相當於是 CRUD 的衍生，只是傳輸介質變了。
4. LocalStorage。LocalStorage 算是另外一種方式的 CRUD。

說了這麼多都是廢話，他們都是可以用類 CRUD 的方式操作。

###檔案儲存

通常來說，以這種方式儲存最常見的方式是 log(日誌)，如 Nginx 的 access.log。像這樣的檔案就需要一些專業的軟體，如 GoAccess、又或者是 Hadoop、Spark 來做對應的事。

在資料庫出現之前，人們都是使用檔案來儲存資料的。資料以檔案為單位儲存在硬碟上，並且這些檔案不容易一起管理、修改等等。如下圖所示的是我早期儲存檔案的一種方式：

```
├── 3.12
│   ├── cover.png
│   └── favicon.ico
└── 3.13
    └── template.tex
```

每天我們都會修改、檢視大量的不同類型的檔案。而由於工作繁忙，我們可能沒有辦法一一地去分類這些檔案。有時選擇的便是，優先先按日期把檔案一劃分，接著再在隨後的日子裡歸檔。而這種儲存方式大量的依賴於人來索引的工作，在很多時候往往顯得不是很靠譜。並且當我們將資料儲存進去後，往往很難進行修改。大量的 Log 檔案就需要專門的工作來分析和使用，依賴於人來解析這些日誌往往顯得不是很靠譜。這時我們就需要一些重量級的工具，如用 Logstash、ElasticSearch、Kibana 來處理 Nginx 訪問日誌。

而對於那些非專業人員來說，使用 Excel 這樣的工具往往顯得比較方便。他們不需要去操作資料庫，也不需要專業的知識來處理這些知識。只是從某種意義上來說，Excel 應該歸屬於資料庫的範疇。

###資料庫

當我們開始一個 Web 應用的時候，如建立一個使用者管理系統，我們就需要不斷對檔案進行查詢、修改、插入和刪除等操作。不僅如此，我們還需要定義資料之間的關係，如這個使用者對應這個密碼。在一些更復雜的情況下，我們還需要尋找這些使用者中對應的一些操作資料等等。如果還是將這些工作交給檔案來處理，那麼我們便是在向自己挖坑。

> 資料庫，簡單來說可視為電子化的檔案櫃——儲存電子檔案的處所，使用者可以對檔案中的資料執行新增、擷取、更新、刪除等操作。

在操作庫的時候，我們會使用到一名為 SQL（英語：Structural Query Language，中文： 結構化查詢語言）的領域特定語言來對資料進行操作。

> SQL 是高階的非過程化程式語言，它允許使用者在高層資料結構上工作。它不要求使用者指定對資料的存放方法，也不需要使用者瞭解其具體的資料存放方式。

資料庫裡儲存著大量的資料，在我們對系統建模的時候，也在決定系統的基礎模型。

####ORM

在傳統 SQL 資料庫中，我們可能會依賴於 ORM，也可能會自己寫 SQL。在使用 ORM 框架時，我們需要先定義 Model，如下是 Node.js 的 ORM 框架 Sequelize 的一個示例：

```javascript
var User = sequelize.define('user', {
  firstName: {
    type: Sequelize.STRING,
    field: 'first_name'
  },
  lastName: {
    type: Sequelize.STRING
  }
}, {
  freezeTableName: true
});

User.sync({force: true}).then(function () {
  // Table created
  return User.create({
    firstName: 'John',
    lastName: 'Hancock'
  });
});
```

上面定義的 Model，在程式初始化的時候將會建立相應的資料庫欄位。並且會建立一個 firstName 為 'John'，lastName 為 'Hancock' 的使用者。而這個過程中，我們並不需要操作資料庫。

像 MongoDB 這類的資料庫，也存在資料模型，但說的卻是嵌入子文件。在業務量大的情況下，資料庫在考驗公司的技術能力，想想便覺得 Amazon RDS 挺好的。

###搜尋引擎

儘管百科上對於搜尋引擎的定義是這樣的：

> 搜尋引擎指自動從因特網蒐集資訊，經過一定整理以後，提供給使用者進行查詢的系統。

但是這樣描述並不是非常準確，因為有相當多的網站採用了搜尋引擎作為基礎的儲存服務架構，而且他們並非自動從網際網路上搜尋資訊。搜尋引擎應該分成三個部分來組成：

1. 索引服務
2. 搜尋服務
3. 索引資料

索引服務用於將資料儲存到索引資料中，而搜尋服務正是搜尋引擎存在的意義。對於查詢條件複雜的網站來說，採用搜尋引擎就意味著減少了非常多的繁瑣資料處理事務。在一些架構中，人們用資料庫儲存資料，並使用工具來將資料注入到搜尋引擎中。

從架構上來說，使用搜尋引擎的優點是：分離儲存、查詢部分。從開發上來說，它可以讓我們更關注於業務本身的價值，而不是去實現這樣一個搜尋邏輯。

如下圖所示的 Lucene 應用的架構：

![Lucene 應用架構](assets/article/chapter2/lucene-arch.jpg)

可以從圖中看到系統明顯被劃分成兩部分：

1. Index Documents。索引文件部分，將用於儲存資料到檔案系統中。
2. Search Index。搜尋部分，用於查詢相應的資料。
