可讀的程式碼
---

過去，我有過在不同的場合吐槽別人的程式碼寫得爛。而我寫的僅僅是比別人好一點而已——而不是好很多。

然而這是一件很難的事，人們對於同一件事物未來的考慮都是不一樣的。同樣的程式碼在相同的情景下，不同的人會有不同的設計模式。同樣的程式碼在不同的情景下，同樣的人會有不同的設計模式。在這裡，我們沒有辦法討論設計模式，也不需要討論。

我們所需要做的是，確保我們的程式碼易讀、易測試，看上去這樣就夠了，然而這也是挺複雜的一件事:

 - 確保我們的變數名、函數名是易讀的
 - 沒有複雜的邏輯判斷
 - 沒有多層巢狀 (事不過三)
 - 減少複雜函數的出現（如,不超過三十行）
 - 然後，你要去測試它。這樣你就知道需要什麼，實際上要做到這些也不是一些難事。

只是首先，我們要知道我們要自己需要這些。對於沒有太多程式設計經驗的人，建議先從兩個基本點做起：

 - 命名
 - 函數長度

首先要說的就是程式設計師認為最難的一個話題了——命名。

###命名

命名是一個特別長的，也是特別憂傷的故事。我想作為一個程式設計師的你，也相當恐懼這件事。一個好的函數名、變數名應該包含著這個函數的資訊，如這個函數是幹什麼的，或者這個函數是怎麼來的，這個變數名儲存的是什麼。

正因為取名字是一件很重要的事，所以它也是一件很難的事。一個好的函數名、變數名應該能正確地表達出它的涵義。如你可以猜到下面的程式碼中的i是什麼意思嗎？

```python
fruits = ['banana', 'apple',  'mango']
for i in fruits:        # Second Example
   print 'Current fruit :', i
```

那如果換成下面的程式碼會不會更容易閱讀呢？


```python
fruits = ['banana', 'apple',  'mango']
for fruit in fruits:        # Second Example
   print 'Current fruit :', fruit
```

而命令還存在於對函數的命名上，如我們可能會用 getNumber 來表示去獲取一個數值，但是要知道這樣的命名並不是在所有的語言中都可以這樣用。如在 Java 中存在 getter 和 setter 這種模式，如下的程式碼所示：

```
public String getNumber() {
  return number;
}
public void setNumber(String number) {
  this.number = number;
}
```

如果我們是去取某個東西的數值，那麼我們應該使用 retrieveNumber 這樣的更具代表性的名字。

在《編寫可讀程式碼的藝術》也提到了這幾點：

1. 選擇專業的詞。最好是可以和業務相關的，它應該極具表現力。
2. 避免像 tmp 和 retval 這樣泛泛的名字。不得不提到的一點是，tmp 實在是一個有夠爛的名字，將其變為 timeTemp 或者類似的會更直觀。它只應該是名字中的一部分。
3. 用具體的名字代替抽象的名字。
4. 為名字賦予更多的資訊。
5. 名字應該有多長。
6. 利用名字的格式來傳遞含義。

###函數長度

> 函數是指一段在一起的、可以做某一件事兒的程式。

這就意味著從定義上來說，這段函數應該只做一件事——但是什麼才是真正的一件事呢？實際上還是 TASKING，將一個複雜的過程一步步地分解成一個個的函數，每個函數只做他的名稱對應的事。對於一個任務來說，他有一個穩定的過程，在這個過程中的每一步都可以變成一個函數。

因此，長的程式碼意味著一件事——這個函數可能違反了單一職責原則，即這個類做了太多的事。通常來說，一個類，只有一個引起它變化的原因。當一個類有多個職責的時候，這些程式碼就容易耦合到一起了。

對於函數長度的控制是為了有效控制分支深度。如果我們用一個函數來實現一個複雜的功能，那麼不僅僅在我們下次閱讀的時間會花費大量的時間。而且如果我們的程式碼沒有測試的話，這些程式碼就會變得越來越難以理解。而在我們寫這些函數的時候就沒有測試，那麼這個函數就會變得越來越難以測試，它們就會變成遺留程式碼。

###其他

雖然只想介紹上面的簡單的兩點，但是順便在這裡也提一下重複程式碼~~。

####重複程式碼

在《重構》一書中首先提到的 Code Smell 就是重複程式碼（Duplicate Code）。重複程式碼看上去並不會影響我們的閱讀體驗，但是實際上會發生這樣的事——重複的程式碼閱讀體驗越不好。

DRY(Don't Repeat Yourself)原則是特別值得玩味的。當我們不斷地偏執的去減少重複程式碼的時候，會導致複雜度越來越高。在適當的時候，由於業務發生變更，我們還需要去拆解這些不重複的程式碼。
